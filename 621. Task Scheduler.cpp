// 这个是别人的思路。统计词频，然后排序后，
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> c(26,0);
        for(auto t:tasks)
            c[t-'A']++;
        sort(c.begin(), c.end());
        int i=25;
        while(i>=0 && c[i]==c[25])
            i--;
        return max(int(tasks.size()), (c[25]-1)*(n+1)+25-i);
    }
};


// 1.先统计词频，再排序，从后往前找到第一个不是最大词频的下标i，结果是tasks.length或(c[25] - 1) * (n + 1) + 25 – i中大的那一个，25-i就是最大词频的任务类，这个和我的思路是一样的。证明：最大词频是k，则创建k个块，每一块开头是最大词频的任务构成的(输入AACCCDDEEE，则开头是CE)，词频由大到小插入每一块。97.69%，10ms。
// 2.贪心，利用优先队列排序：队列中保存<类型，个数>的map，并且按照个数由大到小排序。按照词频由大到小取出n+1个或者队列中全部(若没有取出全部，则总长度要加上空闲个数)，再把词频-1之后不为0的放回队列中。直到队列空了为止。——其实也和前面相同，总是选择词频最大的填入每一块。
// 3.使用操作系统的思想，在时间为time的时候，把time-1-n冻结的任务放回等待队列waitingQueue，在一个循环结束的时候，如果还有这一类task待完成，放到tasksTable。具体做法：先用HashMap统计词频，再用优先队列waitingQueue排序，声明一个冷却HashMap表coolDownTable，当队列不空或者冷却表不空的时候，找到冷却表time-n-1对应的任务char，拿出放到等待队列中，如果等待队列不空{拿出任务，剩余任务个数-1并放到tasksTable，如果剩余任务个数不为0放到coolDownTable.put(time, task); } time++。返回time
// 4.类似上面，模拟的思想：对于m个任务，先是每类任务的冷却时间-1，然后找到词频最大的任务及其下标，如果它的词频>-1，则取这个任务（词频-1，处理++，冷却时间+n）；否则（所有任务词频都为-1），空闲+1.返回处理+空闲时间
// 我想到的是贪心的算法。